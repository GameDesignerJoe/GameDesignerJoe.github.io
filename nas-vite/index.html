<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>NOT ALL SURVIVVE</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background-color: #1B4B7C;
            color: white;
            min-height: 100vh;
            width: 100%;
            overscroll-behavior: none;
            touch-action: none;
        }

        .game-container {
            width: 100%;
            max-width: 450px;
            margin: 0 auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: env(safe-area-inset-top, 20px);
            padding-bottom: env(safe-area-inset-bottom, 20px);
        }

        h1 {
            font-size: 24px;
            margin-bottom: 20px;
            text-align: center;
        }

        .grid-container {
            width: 100%;
            aspect-ratio: 1;
            position: relative;
            background: rgba(0, 0, 0, 0.2);
            touch-action: none;
            overflow: hidden;
            border-radius: 8px;
        }

        .stats-container {
        width: 100%;
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
        padding: 0 10px;
        }

        .stat {
            flex: 1;
        }

        .stat-bar {
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
        }

        .stat-fill {
            height: 100%;
            width: 100%;
            transition: width 0.3s ease;
        }

        #health-bar {
            background-color: #ff4444;
        }

        #stamina-bar {
            background-color: #44aaff;
        }

        #hunger-bar {
            background-color: #ffaa44;
        }

        @keyframes pulseRed {
            0% { background-color: rgba(255, 68, 68, 0.1); }
            50% { background-color: rgba(255, 68, 68, 0.3); }
            100% { background-color: rgba(255, 68, 68, 0.1); }
        }

        .stat-bar.pulse-warning {
            animation: pulseRed 0.5s ease-in-out 3;
        }

        .pulse-warning {
            animation: pulseRed 0.5s ease-in-out 3;
        }

        .fog {
        fill: white;  /* Match background color #1B4B7C */
        pointer-events: none;  /* Allow clicks to pass through */
        transition: fill 0.3s ease;
        }

        #message-container {
          width: 100%;
          height: 160px; /* Fixed height */
          margin: 10px 0 20px 0;
          padding: 10px;
          background-color: rgba(255, 255, 255, 0.1);
          border: 1px solid rgba(255, 255, 255, 0.2);
          border-radius: 4px;
          overflow-y: auto; /* Allow scrolling if content is too long */
        }

        /* Optional: Hide scrollbar but keep functionality */
        #message-container {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }
        #message-container::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        #game-message {
            font-family: 'Old Standard TT', serif;
            font-size: 1.1rem;
            text-align: center;
            line-height: 1.4;
            margin: 0;
        }

        #game-message.narrative {
        font-style: italic;
        }

        #game-message.terrain-info {
            font-style: normal;
        }

        #message-container {
          width: 100%;
          min-height: 5em;  /* Approximately 4 lines of text */
          margin: 10px 0 20px 0;
          padding: 10px;
          background-color: rgba(255, 255, 255, 0.1);
          border: 1px solid rgba(255, 255, 255, 0.2);
          border-radius: 4px;
        }

        #game-message h3 {
          font-size: 18px;
          margin-bottom: 10px;
        }

        #game-message p {
            margin-bottom: 10px;
            line-height: 1.4;
        }

        #game-message p:last-child {
            font-style: italic;
            color: rgba(255, 255, 255, 0.8);
        }

    </style>
</head>
<body>
    <div class="game-container">
      <h1>NOT ALL SURVIVE</h1>
      <div id="message-container">
        <p id="game-message" class="narrative">Before you lies the vast Antarctic expanse, untamed and unforgiving. The freezing wind howls a challenge promising either immortal glory or eternal rest beneath the ice.</p>
    </div>
        
      <!-- Add stats bars here -->
      <div class="stats-container">
          <div class="stat">
              <div class="stat-bar">
                  <div class="stat-fill" id="health-bar"></div>
              </div>
          </div>
          <div class="stat">
              <div class="stat-bar">
                  <div class="stat-fill" id="stamina-bar"></div>
              </div>
          </div>
          <div class="stat">
              <div class="stat-bar">
                  <div class="stat-fill" id="hunger-bar"></div>
              </div>
          </div>
      </div>
        
        <div class="grid-container">
            <svg id="gameGrid" width="100%" height="100%" viewBox="0 0 300 300">
                <g id="hexGroup" transform="translate(150, 150)">
                    <!-- Hexes will be added here by JS -->
                </g>
            </svg>
        </div>
    </div>

    <script src="src/config/config.js"></script>
    <script>
        // Grid setup
        const hexSize = 30;
        const hexHeight = hexSize * 2;
        const hexWidth = Math.sqrt(3) * hexSize;
        
        // Player state
        let playerPosition = { q: 0, r: 0 };
        let selectedHex = null;

        // Fog of war tracking
        let visitedHexes = new Set();
        let visibleHexes = new Set();

        // Stats system
        const STATS = {
            MAX_VALUE: 100,
            HEALTH_DECAY: 0.5,    // % per second
            HUNGER_DECAY: 0.25,   // % per second
            MOVE_STAMINA_COST: 5,
            STAMINA_REGEN: 2      // % per second
        };

        let stats = {
            health: STATS.MAX_VALUE,
            stamina: STATS.MAX_VALUE,
            hunger: STATS.MAX_VALUE
        };

        const BASE_HEALING = {
        HEALTH_REGEN: 1,    // % per second
        HUNGER_REGEN: 0.5,  // % per second
        STAMINA_REGEN: 3    // % per second
        };

        // Special locations
        let baseCamp = null;
        let southPole = null;
        let southPoleVisited = false;

        let lastStatUpdate = Date.now();
        let lastMoveTime = Date.now();

        function updateVisibility() {
    // Clear current visible hexes
    visibleHexes.clear();
    
    // Add current position and adjacent hexes
    visibleHexes.add(`${playerPosition.q},${playerPosition.r}`);
    getAdjacentHexes(playerPosition).forEach(hex => {
        visibleHexes.add(`${hex.q},${hex.r}`);
    });
    
    // Update fog overlay for all hexes
    document.querySelectorAll('.fog').forEach(fogHex => {
        // Use data attributes instead of transform
        const q = parseInt(fogHex.getAttribute('data-q'));
        const r = parseInt(fogHex.getAttribute('data-r'));
        const hexId = `${q},${r}`;
        const isBaseCamp = q === baseCamp.q && r === baseCamp.r;
        
        if (isBaseCamp || visibleHexes.has(hexId) || visitedHexes.has(hexId)) {
            fogHex.setAttribute('fill-opacity', '0');
        } else {
            fogHex.setAttribute('fill-opacity', '1');
        }
    });
}

        // Helper function to get adjacent hex coordinates
        function getAdjacentHexes(hex) {
            const directions = [
                {q: 1, r: 0}, {q: 1, r: -1}, {q: 0, r: -1},
                {q: -1, r: 0}, {q: -1, r: 1}, {q: 0, r: 1}
            ];
            
            return directions.map(dir => ({
                q: hex.q + dir.q,
                r: hex.r + dir.r
            }));
        }

        function updateStats() {
          // Only exit if health is zero, not if hunger is zero
          if (stats.health <= 0) return;

          const now = Date.now();
          const deltaTime = (now - lastStatUpdate) / 1000;
          lastStatUpdate = now;

          // Check current terrain for effects
          const currentHex = document.querySelector(`polygon[data-q="${playerPosition.q}"][data-r="${playerPosition.r}"]`);
          const currentTerrain = currentHex ? TERRAIN_TYPES[currentHex.getAttribute('data-terrain')] : null;

          // Check if at base camp
          const atBaseCamp = playerPosition.q === baseCamp.q && playerPosition.r === baseCamp.r;
          
          if (atBaseCamp) {
              // Healing at base camp
              stats.health = Math.min(STATS.MAX_VALUE, stats.health + BASE_HEALING.HEALTH_REGEN * deltaTime);
              stats.hunger = Math.min(STATS.MAX_VALUE, stats.hunger + BASE_HEALING.HUNGER_REGEN * deltaTime);
              stats.stamina = Math.min(STATS.MAX_VALUE, stats.stamina + BASE_HEALING.STAMINA_REGEN * deltaTime);
          } else {
              // Only health decay when not at base camp
              stats.health = Math.max(0, stats.health - STATS.HEALTH_DECAY * deltaTime);
              
              // Apply ice field damage over time if standing on ice
              if (currentTerrain && currentTerrain.healthRisk) {
                  stats.health = Math.max(0, stats.health - (currentTerrain.healthRisk * 100 * deltaTime));
              }
              
              // Always try to regenerate stamina if we haven't moved recently
              const timeSinceLastMove = (now - lastMoveTime) / 1000;
              if (timeSinceLastMove > 0.5) {
                  stats.stamina = Math.min(STATS.MAX_VALUE, 
                      stats.stamina + STATS.STAMINA_REGEN * deltaTime);
              }
          }
          
          // Update stats display after all calculations
          updateStatsDisplay();
          checkDeathCondition();
        } 

function updatePlayerPosition(newQ, newR) {
    const player = document.getElementById('player');
    const center = getHexCenter(newQ, newR);
    
    player.setAttribute("cx", center.x);
    player.setAttribute("cy", center.y);
    
    // Check if moving onto ice field for initial damage
    const targetHex = document.querySelector(`polygon[data-q="${newQ}"][data-r="${newR}"]`);
    const targetTerrain = TERRAIN_TYPES[targetHex.getAttribute('data-terrain')];
    if (targetTerrain && targetTerrain.healthRisk) {
        // Apply immediate damage for stepping on ice
        stats.health = Math.max(0, stats.health - (targetTerrain.healthRisk * 100));
        // Add visual/text feedback
        document.getElementById('game-message').className = 'narrative';
    document.getElementById('game-message').innerHTML = `
        <h3>Dangerous Ice!</h3>
        <p><em>The bitter cold of the ice field bites into you.</em></p>
        <p><em>"The ice here is dangerously cold..."</em></p>
    `;
    }
    
    playerPosition = { q: newQ, r: newR };
    visitedHexes.add(`${newQ},${newR}`);
    updateVisibility();

    // Rest of the function remains the same...
}

        function updateCurrentLocationInfo() {
          const atBaseCamp = playerPosition.q === baseCamp.q && playerPosition.r === baseCamp.r;
          const atSouthPole = southPole && playerPosition.q === southPole.q && playerPosition.r === southPole.r;
          
          if (atBaseCamp) {
              document.getElementById('game-message').innerHTML = `
                  <h3>Base Camp</h3>
                  <p>A safe haven where you can rest and recover.</p>
                  <p><em>"The familiar sight of base camp brings a sense of relief."</em></p>
              `;
          } else if (atSouthPole) {
              document.getElementById('game-message').innerHTML = `
                  <h3>South Pole</h3>
                  <p>The ultimate goal of your expedition.</p>
                  <p><em>"Could this be it? The South Pole itself?"</em></p>
              `;
          } else {
              // Find the hex at current position
              const currentHex = document.querySelector(`polygon[data-q="${playerPosition.q}"][data-r="${playerPosition.r}"]`);
              if (currentHex) {
                  const terrain = currentHex.getAttribute('data-terrain');
                  const terrainInfo = TERRAIN_TYPES[terrain];
                  document.getElementById('game-message').innerHTML = `
                      <h3>${terrainInfo.name}</h3>
                      <p><em>"${terrainInfo.quote}"</em></p>
                  `;
              }
          }
        }

        function updateStatsDisplay() {
          // Ensure stats don't go below 0
          stats.health = Math.max(0, stats.health);
          stats.stamina = Math.max(0, stats.stamina);
          stats.hunger = Math.max(0, stats.hunger);
          
          // Update the bars
          document.getElementById('health-bar').style.width = `${stats.health}%`;
          document.getElementById('stamina-bar').style.width = `${stats.stamina}%`;
          document.getElementById('hunger-bar').style.width = `${stats.hunger}%`;
        }

        function checkDeathCondition() {
          if (stats.health <= 0) {
              document.getElementById('game-message').className = 'narrative';
              document.getElementById('game-message').innerHTML = 
                  "The bitter cold claims another victim. Your journey ends here.";
              // Turn off the stats update loop?
              return true;
          } else if (stats.hunger <= 0) {
              // Don't show message, just flash the bars
              const healthBar = document.getElementById('health-bar').parentElement;
              const hungerBar = document.getElementById('hunger-bar').parentElement;
              healthBar.classList.add('pulse-warning');
              hungerBar.classList.add('pulse-warning');
              setTimeout(() => {
                  healthBar.classList.remove('pulse-warning');
                  hungerBar.classList.remove('pulse-warning');
              }, 1500);
              return false;
          }
          return false;
        } 


        // Helper functions remain the same
        function createHexPoints(size) {
            const points = [];
            for (let i = 0; i < 6; i++) {
                const angle = (60 * i - 30) * Math.PI / 180;
                points.push(`${size * Math.cos(angle)},${size * Math.sin(angle)}`);
            }
            return points.join(' ');
        }

        function getHexCenter(q, r) {
            const x = hexWidth * (q + r/2);
            const y = hexHeight * (r * 3/4);
            return { x, y };
        }

        function hexDistance(hex1, hex2) {
            return (Math.abs(hex1.q - hex2.q) + 
                   Math.abs(hex1.q + hex1.r - hex2.q - hex2.r) + 
                   Math.abs(hex1.r - hex2.r)) / 2;
        }

        function isAdjacent(hex1, hex2) {
            return hexDistance(hex1, hex2) === 1;
        }

        // Create and update player marker
        function createPlayerMarker() {
            const player = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            const center = getHexCenter(playerPosition.q, playerPosition.r);
            
            player.setAttribute("cx", center.x);
            player.setAttribute("cy", center.y);
            player.setAttribute("r", hexSize * 0.3);
            player.setAttribute("fill", "green");
            player.setAttribute("id", "player");
            player.setAttribute("stroke", "white");
            player.setAttribute("stroke-width", "2");
            
            document.getElementById('hexGroup').appendChild(player);
        }

        function updatePlayerPosition(newQ, newR) {
    const player = document.getElementById('player');
    const center = getHexCenter(newQ, newR);
    
    player.setAttribute("cx", center.x);
    player.setAttribute("cy", center.y);
    
    playerPosition = { q: newQ, r: newR };
    
    // Add new position to visited hexes
    visitedHexes.add(`${newQ},${newR}`);
    
    
    // Update fog of war
    updateVisibility();

    // Check for south pole and victory conditions...
    if (newQ === southPole.q && newR === southPole.r) {
    if (!southPoleVisited) {
        southPoleVisited = true;
        document.getElementById('game-message').className = 'narrative';
        document.getElementById('game-message').innerHTML = 
            "At last! Through bitter cold and endless white, you've reached the South Pole! You plant your flag in triumph, but your journey is far from over. You must now make the perilous trek back to base camp if you hope to tell the world of your discovery.";
    }
}

if (southPoleVisited && newQ === baseCamp.q && newR === baseCamp.r) {
    document.getElementById('game-message').className = 'narrative';
    document.getElementById('game-message').innerHTML = 
        "Against all odds, you've done it! You've not only reached the South Pole but survived the return journey. Your name will be forever etched in the annals of polar exploration. Future generations will speak of your incredible feat of survival and discovery.";
}

    selectedHex = null;
    resetHexColors();
    updateCurrentLocationInfo();
}


function resetHexColors() {
    // Only select polygons that have terrain data
    document.querySelectorAll('polygon[data-terrain]').forEach(hex => {
        const terrain = hex.getAttribute('data-terrain');
        if (terrain === 'BASE_CAMP') {
            hex.setAttribute('fill', SPECIAL_LOCATIONS.BASE_CAMP.color);
        } else if (terrain === 'SOUTH_POLE') {
            hex.setAttribute('fill', SPECIAL_LOCATIONS.SOUTH_POLE.color);
        } else {
            hex.setAttribute('fill', TERRAIN_TYPES[terrain].color);
        }
        // Reset stroke to white
        hex.setAttribute('stroke', '#ffffff');
        hex.setAttribute('stroke-width', '1');
    });
}

function handleHexClick(event) {
    event.preventDefault();
    const hex = event.target;
    const q = parseInt(hex.getAttribute('data-q'));
    const r = parseInt(hex.getAttribute('data-r'));
    const hexId = `${q},${r}`;
    const terrain = hex.getAttribute('data-terrain');

    // Only allow interaction with visible or visited hexes
    if (!visibleHexes.has(hexId) && !visitedHexes.has(hexId) && 
        !(q === baseCamp.q && r === baseCamp.r)) {
        return;
    }

    // Get terrain info based on type
    const terrainInfo = terrain === 'BASE_CAMP' ? SPECIAL_LOCATIONS.BASE_CAMP :
                      terrain === 'SOUTH_POLE' ? SPECIAL_LOCATIONS.SOUTH_POLE :
                      TERRAIN_TYPES[terrain];

    // Check if movement is possible
    const isAdjacentToPlayer = isAdjacent({ q, r }, playerPosition);
    const staminaCost = terrainInfo.staminaCost || STATS.MOVE_STAMINA_COST;
    const canMove = isAdjacentToPlayer && 
                  terrainInfo.passable && 
                  stats.stamina >= staminaCost;

    // Reset all hex colors first
    resetHexColors();

    if (selectedHex && selectedHex === hex) {
    // Second click on the same hex - attempt to move
    if (isAdjacentToPlayer) {
        if (!terrainInfo.passable) {
            // Show terrain info but add impassable note
            document.getElementById('game-message').className = 'terrain-info';
            document.getElementById('game-message').innerHTML = `
                <h3>${terrainInfo.name}</h3>
                <p><em>"${terrainInfo.quote}"</em></p>
                <p>This terrain is impassable!</p>
            `;
        } else if (stats.stamina < staminaCost) {
            // Show terrain info but add stamina warning
            document.getElementById('game-message').className = 'terrain-info';
            document.getElementById('game-message').innerHTML = `
                <h3>${terrainInfo.name}</h3>
                <p><em>"${terrainInfo.quote}"</em></p>
                <p>You are too exhausted to move.</p>
            `;
            // Flash stamina bar
            const staminaBar = document.getElementById('stamina-bar').parentElement;
            staminaBar.classList.add('pulse-warning');
            setTimeout(() => staminaBar.classList.remove('pulse-warning'), 1500);
        } else {
            // Move and handle consequences
            stats.stamina -= staminaCost;
            
            // Handle hunger and its effects
            if (stats.hunger > 5) {
                stats.hunger -= 5;
            } else {
                stats.hunger = 0;
                stats.health = Math.max(0, stats.health - 5);
                stats.stamina = Math.max(0, stats.stamina - 5);
                
                // Flash health and stamina bars
                const healthBar = document.getElementById('health-bar').parentElement;
                const staminaBar = document.getElementById('stamina-bar').parentElement;
                healthBar.classList.add('pulse-warning');
                staminaBar.classList.add('pulse-warning');
                setTimeout(() => {
                    healthBar.classList.remove('pulse-warning');
                    staminaBar.classList.remove('pulse-warning');
                }, 1500);
            }
            
            lastMoveTime = Date.now();
            updateStatsDisplay();
            updatePlayerPosition(q, r);
        }
    }
    selectedHex = null;
    } else {
      // First click - always show terrain info
      selectedHex = hex;
      hex.setAttribute('stroke', '#000000');
      hex.setAttribute('stroke-width', '3');
      
      // Always show terrain info
      document.getElementById('game-message').className = 'terrain-info';
      document.getElementById('game-message').innerHTML = `
          <h3>${terrainInfo.name}</h3>
          <p><em>"${terrainInfo.quote}"</em></p>
          ${terrainInfo.healthRisk ? `<p>Health risk: ${terrainInfo.healthRisk * 100}% damage</p>` : ''}
      `;
    }
  }

        // Create the hex grid
        function createHexGrid() {
    const group = document.getElementById('hexGroup');
    const gridSize = 3;
    
    // Position base camp in top row with valid q coordinate
    let baseQ, baseR;
    baseR = -gridSize;  // Force it to be in the top row
    
    // Calculate valid q range for this r value
    const minQ = Math.max(-gridSize, -gridSize - baseR);
    const maxQ = Math.min(gridSize, gridSize - baseR);
    baseQ = minQ + Math.floor(Math.random() * (maxQ - minQ + 1));
    
    baseCamp = { q: baseQ, r: baseR };
    
    // Position player at base camp initially
    playerPosition = { q: baseQ, r: baseR };
    
    // Position south pole in bottom row
    let southQ;
    let southR;
    do {
        southR = gridSize;  // Force it to be in the bottom row
        // Use same q range calculation for bottom row
        const minSouthQ = Math.max(-gridSize, -gridSize - southR);
        const maxSouthQ = Math.min(gridSize, gridSize - southR);
        southQ = minSouthQ + Math.floor(Math.random() * (maxSouthQ - minSouthQ + 1));
    } while (southQ === baseQ && southR === baseR);
    southPole = { q: southQ, r: southR };
    
    // Create terrain hexes
    for (let q = -gridSize; q <= gridSize; q++) {
        for (let r = -gridSize; r <= gridSize; r++) {
            if (Math.abs(q + r) <= gridSize) {
                const x = hexWidth * (q + r/2);
                const y = hexHeight * (r * 3/4);
                
                // Create terrain hex
                const hex = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                let terrain;
                
                if (q === baseCamp.q && r === baseCamp.r) {
                    terrain = 'BASE_CAMP';
                    hex.setAttribute("fill", SPECIAL_LOCATIONS.BASE_CAMP.color);
                } else if (q === southPole.q && r === southPole.r) {
                    terrain = 'SOUTH_POLE';
                    hex.setAttribute("fill", SPECIAL_LOCATIONS.SOUTH_POLE.color);
                } else {
                    terrain = assignRandomTerrain();
                    hex.setAttribute("fill", TERRAIN_TYPES[terrain].color);
                }
                
                hex.setAttribute("points", createHexPoints(hexSize));
                hex.setAttribute("transform", `translate(${x}, ${y})`);
                hex.setAttribute("stroke", "#ffffff");
                hex.setAttribute("stroke-width", "1");
                hex.setAttribute("data-q", q);
                hex.setAttribute("data-r", r);
                hex.setAttribute("data-terrain", terrain);
                
                hex.addEventListener('pointerdown', handleHexClick);
                group.appendChild(hex);
                
                // Create fog overlay for this hex
                const fog = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                fog.setAttribute("points", createHexPoints(hexSize));
                fog.setAttribute("transform", `translate(${x}, ${y})`);
                fog.setAttribute("class", "fog");
                fog.setAttribute("data-q", q);
                fog.setAttribute("data-r", r);
                fog.setAttribute("fill-opacity", "1");
                fog.setAttribute("id", `fog-${q},${r}`);
                group.appendChild(fog);
            }
        }
    }

    // Initialize visibility
    visitedHexes.add(`${playerPosition.q},${playerPosition.r}`);
    createPlayerMarker();
    updateVisibility();
    updateCurrentLocationInfo();
}

        // Keep existing pan handling code
        let isPanning = false;
        let startX = 0;
        let startY = 0;
        let currentTranslateX = 150;
        let currentTranslateY = 150;

        const hexGroup = document.getElementById('hexGroup');
        const gameGrid = document.getElementById('gameGrid');

        gameGrid.addEventListener('pointerdown', (e) => {
            isPanning = true;
            startX = e.clientX - currentTranslateX;
            startY = e.clientY - currentTranslateY;
        });

        gameGrid.addEventListener('pointermove', (e) => {
            if (!isPanning) return;
            
            currentTranslateX = e.clientX - startX;
            currentTranslateY = e.clientY - startY;
            
            hexGroup.setAttribute('transform', 
                `translate(${currentTranslateX}, ${currentTranslateY})`);
        });

        gameGrid.addEventListener('pointerup', () => {
            isPanning = false;
        });

        gameGrid.addEventListener('pointercancel', () => {
            isPanning = false;
        });

        // Initialize
        createHexGrid();
        // Start the stats update loop
        setInterval(updateStats, 50);
    
        function restartGame() {
          stats.health = STATS.MAX_VALUE;
          stats.stamina = STATS.MAX_VALUE;
          stats.hunger = STATS.MAX_VALUE;
          southPoleVisited = false;
          visitedHexes.clear();
          visitedHexes.add(`${baseCamp.q},${baseCamp.r}`);
          updatePlayerPosition(baseCamp.q, baseCamp.r);
          document.getElementById('game-message').textContent = 
              "Before you lies the vast Antarctic expanse, untamed and unforgiving. The freezing wind howls a challenge promising either immortal glory or eternal rest beneath the ice.";
        }
    </script>
</body>
</html>