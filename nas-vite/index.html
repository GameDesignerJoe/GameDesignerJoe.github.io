<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>NOT ALL SURVIVVE</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background-color: #1B4B7C;
            color: white;
            min-height: 100vh;
            width: 100%;
            overscroll-behavior: none;
            touch-action: none;
        }

        .game-container {
            width: 100%;
            max-width: 450px;
            margin: 0 auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: env(safe-area-inset-top, 20px);
            padding-bottom: env(safe-area-inset-bottom, 20px);
        }

        h1 {
            font-size: 24px;
            margin-bottom: 20px;
            text-align: center;
        }

        .grid-container {
            width: 100%;
            aspect-ratio: 1;
            position: relative;
            background: rgba(0, 0, 0, 0.2);
            touch-action: none;
            overflow: hidden;
            border-radius: 8px;
        }

        .stats-container {
    width: 100%;
    display: flex;
    gap: 8px;
    margin-bottom: 20px;
    padding: 0 10px;
}

.stat {
    flex: 1;
    display: flex;
    align-items: center;
    gap: 4px;
    width: calc(33.33% - 6px); /* Equal width minus the gap */
}

.stat-icon {
    width: 20px;  /* Slightly smaller icons */
    height: 20px;
    flex-shrink: 0;
}

.stat-bar {
    flex: 1;
    height: 16px;  /* Slightly smaller height */
    background: rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    overflow: hidden;
    min-width: 0;
}

.stat-fill {
    height: 100%;
    width: 0%;
    transition: width 0.3s ease;
}

        #health-bar {
            background-color: #ff4444;
        }

        #stamina-bar {
            background-color: #44aaff;
        }

        #hunger-bar {
            background-color: #ffaa44;
        }

        @keyframes pulseRed {
            0% { background-color: rgba(255, 68, 68, 0.1); }
            50% { background-color: rgba(255, 68, 68, 0.3); }
            100% { background-color: rgba(255, 68, 68, 0.1); }
        }

        .stat-bar.pulse-warning {
            animation: pulseRed 0.5s ease-in-out 3;
        }

        .pulse-warning {
            animation: pulseRed 0.5s ease-in-out 3;
        }

        .fog {
        fill: white;  /* Match background color #1B4B7C */
        pointer-events: none;  /* Allow clicks to pass through */
        transition: fill 0.3s ease;
        }

        #message-container {
          width: 100%;
          height: 160px; /* Fixed height */
          margin: 10px 0 20px 0;
          padding: 10px;
          background-color: rgba(255, 255, 255, 0.1);
          border: 1px solid rgba(255, 255, 255, 0.2);
          border-radius: 4px;
          overflow-y: auto; /* Allow scrolling if content is too long */
        }

        /* Optional: Hide scrollbar but keep functionality */
        #message-container {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }
        #message-container::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        #game-message {
            font-family: 'Old Standard TT', serif;
            font-size: 1.1rem;
            text-align: center;
            line-height: 1.4;
            margin: 0;
        }

        #game-message.narrative {
        font-style: italic;
        }

        #game-message.terrain-info {
            font-style: normal;
        }

        #message-container {
          width: 100%;
          min-height: 5em;  /* Approximately 4 lines of text */
          margin: 10px 0 20px 0;
          padding: 10px;
          background-color: rgba(255, 255, 255, 0.1);
          border: 1px solid rgba(255, 255, 255, 0.2);
          border-radius: 4px;
        }

        #game-message h3 {
          font-size: 18px;
          margin-bottom: 10px;
        }

        #game-message p {
            margin-bottom: 10px;
            line-height: 1.4;
        }

        #game-message p:last-child {
            font-style: italic;
            color: rgba(255, 255, 255, 0.8);
        }

    /* Restart button */
    .restart-button {
            padding: 12px 24px;
            font-family: 'Old Standard TT', serif;
            font-size: 18px;
            background-color: #44aaff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 10px 0;
            transition: background-color 0.2s;
            display: none;
        }

        .restart-button.hidden {
            display: none;
        }

        .restart-button:hover {
            background-color: #3399ee;
        }

.message-slide-enter {
  transform: translateY(-100%);
}

.message-slide-enter-active {
  transform: translateY(0);
  transition: transform 300ms ease-in-out;
}

.message-slide-exit {
  transform: translateY(0);
}

.message-slide-exit-active {
  transform: translateY(-100%);
  transition: transform 300ms ease-in-out;
}

.player-message {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 1rem;
    text-align: center;
    font-style: italic;
    transform: translateY(-100%);
    transition: transform 300ms ease-in-out;
    z-index: 1000;
}

.player-message.visible {
    transform: translateY(0);
}
    </style>
</head>
<body>
  <div class="game-container">
    <h1>NOT ALL SURVIVE</h1>
    <div id="message-container">
      <p id="game-message" class="narrative">Before you lies the vast Antarctic expanse, untamed and unforgiving. The freezing wind howls a challenge promising either immortal glory or eternal rest beneath the ice.</p>
    </div>
    <button id="restart-button" class="restart-button hidden">Start New Expedition</button>    
      <!-- Add stats bars here -->
      <!-- Stats bars with icons -->
      <div class="stats-container">
          <div class="stat">
              <img src="public/art/health.svg" alt="Health" class="stat-icon">
              <div class="stat-bar">
                  <div class="stat-fill" id="health-bar"></div>
              </div>
          </div>
          <div class="stat">
              <img src="public/art/stamina.svg" alt="Stamina" class="stat-icon">
              <div class="stat-bar">
                  <div class="stat-fill" id="stamina-bar"></div>
              </div>
          </div>
          <div class="stat">
              <img src="public/art/food.svg" alt="Hunger" class="stat-icon">
              <div class="stat-bar">
                  <div class="stat-fill" id="hunger-bar"></div>
              </div>
          </div>
      </div>
        
        <div class="grid-container">
          <div id="player-message" class="player-message">
            <p id="player-message-text"></p>
        </div>
          <svg id="gameGrid" width="100%" height="100%" viewBox="-150 -150 300 300">
              <g id="hexGroup">
                    <!-- Hexes will be added here by JS -->
                </g>
            </svg>
        </div>
    </div>

    <script src="src/config/config.js"></script>
<script>
// Grid setup
let gameRunning = true;

const hexSize = 30;
const hexHeight = hexSize * 2;
const hexWidth = Math.sqrt(3) * hexSize;

// Player state
let playerPosition = { q: 0, r: 0 };
let selectedHex = null;

// Fog of war tracking
let visitedHexes = new Set();
let visibleHexes = new Set();

// Stats system
const STATS = {
    MAX_VALUE: 100,
    HEALTH_DECAY: 0.5,    // % per second
    HUNGER_DECAY: 0.25,   // % per second
    MOVE_STAMINA_COST: 5,
    STAMINA_REGEN: 2      // % per second
};

let stats = {
    health: STATS.MAX_VALUE,
    stamina: STATS.MAX_VALUE,
    hunger: STATS.MAX_VALUE
};

const BASE_HEALING = {
HEALTH_REGEN: 1,    // % per second
HUNGER_REGEN: 0.5,  // % per second
STAMINA_REGEN: 3    // % per second
};

// Special locations
let baseCamp = null;
let southPole = null;
let southPoleSpotted = false;
let southPoleVisited = false;

let lastStatUpdate = Date.now();
let lastMoveTime = Date.now();

let activeMessageTimeout = null;
let currentMessageType = null;

// Message types
const MESSAGE_TYPES = {
    TERRAIN: 'terrain',     // For terrain-related messages (impassable, exhaustion)
    STATUS: 'status',       // For important status messages (starving, victory)
};

function showInitialMessage() {
    document.getElementById('game-message').className = 'narrative';
    document.getElementById('game-message').innerHTML = 
        "Before you lies the vast Antarctic expanse, untamed and unforgiving. The freezing wind howls a challenge promising either immortal glory or eternal rest beneath the ice.";
}

function showPlayerMessage(message, type = MESSAGE_TYPES.TERRAIN) {
    // Don't override STATUS messages with TERRAIN messages
    if (currentMessageType === MESSAGE_TYPES.STATUS && type === MESSAGE_TYPES.TERRAIN) {
        return;
    }

    const messageContainer = document.getElementById('player-message');
    const messageText = document.getElementById('player-message-text');
    
    // Clear any existing timeout
    if (activeMessageTimeout) {
        clearTimeout(activeMessageTimeout);
    }
    
    // Update message text and show container
    messageText.textContent = message;
    messageContainer.classList.add('visible');
    currentMessageType = type;
    
    // Only set timeout for TERRAIN messages
    if (type === MESSAGE_TYPES.TERRAIN) {
        activeMessageTimeout = setTimeout(() => {
            messageContainer.classList.remove('visible');
            currentMessageType = null;
        }, 5000);
    }
}

function clearTerrainMessage() {
    if (currentMessageType === MESSAGE_TYPES.TERRAIN) {
        const messageContainer = document.getElementById('player-message');
        messageContainer.classList.remove('visible');
        currentMessageType = null;
        if (activeMessageTimeout) {
            clearTimeout(activeMessageTimeout);
            activeMessageTimeout = null;
        }
    }
}

function updateVisibility() {
    // Clear current visible hexes
    visibleHexes.clear();
    
    // Add current position and adjacent hexes
    visibleHexes.add(`${playerPosition.q},${playerPosition.r}`);
    getAdjacentHexes(playerPosition).forEach(hex => {
        visibleHexes.add(`${hex.q},${hex.r}`);
    });
    
    // Update fog overlay for all hexes
    document.querySelectorAll('.fog').forEach(fogHex => {
        // Use data attributes instead of transform
        const q = parseInt(fogHex.getAttribute('data-q'));
        const r = parseInt(fogHex.getAttribute('data-r'));
        const hexId = `${q},${r}`;
        const isBaseCamp = q === baseCamp.q && r === baseCamp.r;
        
        if (isBaseCamp || visibleHexes.has(hexId) || visitedHexes.has(hexId)) {
            fogHex.setAttribute('fill-opacity', '0');
        } else {
            fogHex.setAttribute('fill-opacity', '1');
        }
    });
}

        // Helper function to get adjacent hex coordinates
        function getAdjacentHexes(hex) {
            const directions = [
                {q: 1, r: 0}, {q: 1, r: -1}, {q: 0, r: -1},
                {q: -1, r: 0}, {q: -1, r: 1}, {q: 0, r: 1}
            ];
            
            return directions.map(dir => ({
                q: hex.q + dir.q,
                r: hex.r + dir.r
            }));
        }

        function updateStats() {
          // Only exit if health is zero, not if hunger is zero
          if (stats.health <= 0) return;

          const now = Date.now();
          const deltaTime = (now - lastStatUpdate) / 1000;
          lastStatUpdate = now;

          // Check current terrain for effects
          const currentHex = document.querySelector(`polygon[data-q="${playerPosition.q}"][data-r="${playerPosition.r}"]`);
          const currentTerrain = currentHex ? TERRAIN_TYPES[currentHex.getAttribute('data-terrain')] : null;

          // Check if at base camp
          const atBaseCamp = playerPosition.q === baseCamp.q && playerPosition.r === baseCamp.r;
          
          if (atBaseCamp) {
              // Healing at base camp
              stats.health = Math.min(STATS.MAX_VALUE, stats.health + BASE_HEALING.HEALTH_REGEN * deltaTime);
              stats.hunger = Math.min(STATS.MAX_VALUE, stats.hunger + BASE_HEALING.HUNGER_REGEN * deltaTime);
              stats.stamina = Math.min(STATS.MAX_VALUE, stats.stamina + BASE_HEALING.STAMINA_REGEN * deltaTime);
          } else {
              // Only health decay when not at base camp
              stats.health = Math.max(0, stats.health - STATS.HEALTH_DECAY * deltaTime);
              
              // Apply ice field damage over time if standing on ice
              if (currentTerrain && currentTerrain.healthRisk) {
                  stats.health = Math.max(0, stats.health - (currentTerrain.healthRisk * 100 * deltaTime));
              }
              
              // Always try to regenerate stamina if we haven't moved recently
              const timeSinceLastMove = (now - lastMoveTime) / 1000;
              if (timeSinceLastMove > 0.5) {
                  stats.stamina = Math.min(STATS.MAX_VALUE, 
                      stats.stamina + STATS.STAMINA_REGEN * deltaTime);
              }
          }
          
          // Update stats display after all calculations
          updateStatsDisplay();
          checkDeathCondition();
        } 

function updatePlayerPosition(newQ, newR) {
    const player = document.getElementById('player');
    const center = getHexCenter(newQ, newR);
    player.setAttribute("cx", center.x);
    player.setAttribute("cy", center.y);
    
    const targetHex = document.querySelector(`polygon[data-q="${newQ}"][data-r="${newR}"]`);
    const targetTerrain = TERRAIN_TYPES[targetHex.getAttribute('data-terrain')];
    if (targetTerrain && targetTerrain.healthRisk) {
        stats.health = Math.max(0, stats.health - (targetTerrain.healthRisk * 100));
        // Use player message for damage notification
        window.showPlayerMessage("The bitter cold of the ice field bites into you.");
    }
    
    // 3. Update position and visited hexes
    playerPosition = { q: newQ, r: newR };
    visitedHexes.add(`${newQ},${newR}`);
    
    // 4. Update visibility before checking victory conditions
    updateVisibility();
    
    // 5. Check victory conditions
    if (newQ === southPole.q && newR === southPole.r) {
        if (!southPoleVisited) {
            southPoleVisited = true;
            handleVictoryPhase("At last! Through bitter cold and endless white, you've reached the South Pole! You plant your flag in triumph, but your journey is far from over. You must now make the perilous trek back to base camp if you hope to tell the world of your discovery.");
        }
    }

    if (southPoleVisited && newQ === baseCamp.q && newR === baseCamp.r) {
        handleVictoryPhase("Against all odds, you've done it! You've not only reached the South Pole but survived the return journey. Your name will be forever etched in the annals of polar exploration. Future generations will speak of your incredible feat of survival and discovery.");
        const restartBtn = document.getElementById('restart-button');
        restartBtn.classList.remove('hidden');
        restartBtn.style.display = 'block';
    }
    
    // 6. Update UI state
    selectedHex = null;
    resetHexColors();
    updateCurrentLocationInfo();
    
    // 7. Center viewport last (after all position updates are done)
    centerViewport();
}

function updateCurrentLocationInfo() {
    const atBaseCamp = playerPosition.q === baseCamp.q && playerPosition.r === baseCamp.r;
    const atSouthPole = southPole && playerPosition.q === southPole.q && playerPosition.r === southPole.r;
    
    if (atBaseCamp) {
        document.getElementById('game-message').innerHTML = `
            <h3>Base Camp</h3>
            <p><em>"The familiar sight of base camp brings a sense of relief."</em></p>
        `;
    } else if (atSouthPole) {
        document.getElementById('game-message').innerHTML = `
            <h3>South Pole</h3>
            <p><em>"Could this be it? The South Pole itself?"</em></p>
        `;
    } else {
        // Find the hex at current position
        const currentHex = document.querySelector(`polygon[data-q="${playerPosition.q}"][data-r="${playerPosition.r}"]`);
        if (currentHex) {
            const terrain = currentHex.getAttribute('data-terrain');
            const terrainInfo = TERRAIN_TYPES[terrain];
            document.getElementById('game-message').innerHTML = `
                <h3>${terrainInfo.name}</h3>
                <p><em>${terrainInfo.quote}</em></p>
            `;
        }
    }
}

function updateStatsDisplay() {
  // Ensure stats don't go below 0
  stats.health = Math.max(0, stats.health);
  stats.stamina = Math.max(0, stats.stamina);
  stats.hunger = Math.max(0, stats.hunger);
  
  // Update the bars
  document.getElementById('health-bar').style.width = `${stats.health}%`;
  document.getElementById('stamina-bar').style.width = `${stats.stamina}%`;
  document.getElementById('hunger-bar').style.width = `${stats.hunger}%`;
}

function handleDeath(message) {
  // Stop the game
  gameRunning = false;
  
  // Show death message as status message
  showPlayerMessage(message, MESSAGE_TYPES.TERRAIN);
  
  // Show death message in game message area
  document.getElementById('game-message').className = 'narrative';
  document.getElementById('game-message').innerHTML = message;
  
  // Show and setup restart button
  const restartBtn = document.getElementById('restart-button');
  restartBtn.classList.remove('hidden');
  restartBtn.style.display = 'block';
  
  // Clear any existing event listeners
  const newRestartBtn = restartBtn.cloneNode(true);
  restartBtn.parentNode.replaceChild(newRestartBtn, restartBtn);
  
  // Add new event listener
  newRestartBtn.addEventListener('click', () => {
      gameRunning = true;
      restartGame();
      // Clear any status messages when restarting
      clearTerrainMessage();
  });
}

function checkDeathCondition() {
    if (stats.health <= 0) {
        handleDeath("The bitter cold claims another victim. Your journey ends here, in the endless white of Antarctica.");
        return true;
    } else if (stats.hunger <= 0) {
        // Use STATUS type for starvation warning
        showPlayerMessage("Starvation gnaws at your very being. Each step becomes more difficult as your body consumes itself to survive.", MESSAGE_TYPES.STATUS);
        return true;
    }
    return false;
}

        // Helper functions remain the same
        function createHexPoints(size) {
            const points = [];
            for (let i = 0; i < 6; i++) {
                const angle = (60 * i - 30) * Math.PI / 180;
                points.push(`${size * Math.cos(angle)},${size * Math.sin(angle)}`);
            }
            return points.join(' ');
        }

        function getHexCenter(q, r) {
            const x = hexWidth * (q + r/2);
            const y = hexHeight * (r * 3/4);
            return { x, y };
        }

        function hexDistance(hex1, hex2) {
            return (Math.abs(hex1.q - hex2.q) + 
                   Math.abs(hex1.q + hex1.r - hex2.q - hex2.r) + 
                   Math.abs(hex1.r - hex2.r)) / 2;
        }

        function isAdjacent(hex1, hex2) {
            return hexDistance(hex1, hex2) === 1;
        }

        // Create and update player marker
        function createPlayerMarker() {
            const player = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            const center = getHexCenter(playerPosition.q, playerPosition.r);
            
            player.setAttribute("cx", center.x);
            player.setAttribute("cy", center.y);
            player.setAttribute("r", hexSize * 0.3);
            player.setAttribute("fill", "green");
            player.setAttribute("id", "player");
            player.setAttribute("stroke", "white");
            player.setAttribute("stroke-width", "2");
            
            document.getElementById('hexGroup').appendChild(player);
        }

        function centerViewport() {
    const hexGroup = document.getElementById('hexGroup');
    const gameGrid = document.getElementById('gameGrid');
    
    // Get player position in pixel coordinates
    const playerCenter = getHexCenter(playerPosition.q, playerPosition.r);
    
    // Center the player by negating their position
    hexGroup.setAttribute('transform', `translate(${-playerCenter.x}, ${-playerCenter.y})`);
}

function handleVictoryPhase(message) {
    // Show victory messages in the player message system
    window.showPlayerMessage(message);
    
    if (message.includes("forever etched")) {
        const restartBtn = document.getElementById('restart-button');
        restartBtn.classList.remove('hidden');
        restartBtn.style.display = 'block';
        restartBtn.replaceWith(restartBtn.cloneNode(true));
        document.getElementById('restart-button').addEventListener('click', restartGame);
    }
}

function handleDeath(message) {
    // Only called when health hits zero
    gameRunning = false;
    
    document.getElementById('game-message').className = 'narrative';
    document.getElementById('game-message').innerHTML = message;
    
    const restartBtn = document.getElementById('restart-button');
    restartBtn.classList.remove('hidden');
    restartBtn.style.display = 'block';
    
    restartBtn.replaceWith(restartBtn.cloneNode(true));
    document.getElementById('restart-button').addEventListener('click', function() {
        gameRunning = true;
        restartGame();
    });
}

function restartGame() {
  // Hide restart button
  document.getElementById('restart-button').classList.add('hidden');
  document.getElementById('restart-button').style.display = 'none';
  
  // Reset all game state
  stats.health = STATS.MAX_VALUE;
  stats.stamina = STATS.MAX_VALUE;
  stats.hunger = STATS.MAX_VALUE;
  southPoleVisited = false;
  gameRunning = true;
  
  // Clear visited hexes except base camp
  visitedHexes.clear();
  visitedHexes.add(`${baseCamp.q},${baseCamp.r}`);
  
  // Reset player position and update viewport
  updatePlayerPosition(baseCamp.q, baseCamp.r);
  
  // Show starting message
  showInitialMessage();
  
  // Reset timing
  lastStatUpdate = Date.now();
  lastMoveTime = Date.now();
  
  // Update displays
  updateStatsDisplay();
  updateVisibility();
}


function resetHexColors() {
  // Only select polygons that have terrain data
  document.querySelectorAll('polygon[data-terrain]').forEach(hex => {
      const terrain = hex.getAttribute('data-terrain');
      if (terrain === 'BASE_CAMP') {
          hex.setAttribute('fill', SPECIAL_LOCATIONS.BASE_CAMP.color);
      } else if (terrain === 'SOUTH_POLE') {
          hex.setAttribute('fill', SPECIAL_LOCATIONS.SOUTH_POLE.color);
      } else {
          hex.setAttribute('fill', TERRAIN_TYPES[terrain].color);
      }
      // Reset stroke to white
      hex.setAttribute('stroke', '#ffffff');
      hex.setAttribute('stroke-width', '1');
  });
}

function handleHexClick(event) {
    clearTerrainMessage();

    event.preventDefault();
    const hex = event.target;
    const q = parseInt(hex.getAttribute('data-q'));
    const r = parseInt(hex.getAttribute('data-r'));
    const hexId = `${q},${r}`;
    const terrain = hex.getAttribute('data-terrain');

    // Only allow interaction with visible or visited hexes
    if (!visibleHexes.has(hexId) && !visitedHexes.has(hexId) && 
        !(q === baseCamp.q && r === baseCamp.r)) {
        return;
    }

    // Get terrain info based on type
    const terrainInfo = terrain === 'BASE_CAMP' ? SPECIAL_LOCATIONS.BASE_CAMP :
                      terrain === 'SOUTH_POLE' ? SPECIAL_LOCATIONS.SOUTH_POLE :
                      TERRAIN_TYPES[terrain];

    // Check for South Pole spotting first - always show this regardless of stamina
    if (terrain === 'SOUTH_POLE' && !southPoleSpotted && !visitedHexes.has(hexId)) {
        southPoleSpotted = true;
        showPlayerMessage("Your heart pounds as you spot a dark shape through the swirling snow. After all this struggle, could it truly be the Pole?", MESSAGE_TYPES.TERRAIN);
    }

    // Check if movement is possible
    const isAdjacentToPlayer = isAdjacent({ q, r }, playerPosition);
    const staminaCost = terrainInfo.staminaCost || STATS.MOVE_STAMINA_COST;
    const canMove = isAdjacentToPlayer && 
                  terrainInfo.passable && 
                  stats.stamina >= staminaCost;

    // Reset all hex colors first
    resetHexColors();

    if (selectedHex && selectedHex === hex) {
        // Second click on the same hex - attempt to move
        if (isAdjacentToPlayer) {
            if (!terrainInfo.passable) {
                // Use TERRAIN type for impassable message
                showPlayerMessage("This terrain is impassable!", MESSAGE_TYPES.TERRAIN);
                // Keep terrain info in the info panel
                document.getElementById('game-message').innerHTML = `
                    <h3>${terrainInfo.name}</h3>
                    <p><em>${terrainInfo.quote}</em></p>
                `;
            } else if (stats.stamina < staminaCost) {
                // Use TERRAIN type for exhaustion message
                showPlayerMessage("You are too exhausted to move.", MESSAGE_TYPES.TERRAIN);
                // Keep terrain info in the info panel
                document.getElementById('game-message').innerHTML = `
                    <h3>${terrainInfo.name}</h3>
                    <p><em>${terrainInfo.quote}</em></p>
                `;
                // Flash stamina bar
                const staminaBar = document.getElementById('stamina-bar').parentElement;
                staminaBar.classList.add('pulse-warning');
                setTimeout(() => staminaBar.classList.remove('pulse-warning'), 1500);
            } else {
                // Move and handle consequences
                stats.stamina -= staminaCost;
                
                if (stats.hunger > 5) {
                    stats.hunger -= 5;
                } else {
                    stats.hunger = 0;
                    stats.health = Math.max(0, stats.health - 5);
                    stats.stamina = Math.max(0, stats.stamina - 5);
                    // Use STATUS type for hunger effects
                    showPlayerMessage("Your body weakens from hunger...", MESSAGE_TYPES.STATUS);
                    
                    // Flash health and stamina bars
                    const healthBar = document.getElementById('health-bar').parentElement;
                    const staminaBar = document.getElementById('stamina-bar').parentElement;
                    healthBar.classList.add('pulse-warning');
                    staminaBar.classList.add('pulse-warning');
                    setTimeout(() => {
                        healthBar.classList.remove('pulse-warning');
                        staminaBar.classList.remove('pulse-warning');
                    }, 1500);
                }
                
                lastMoveTime = Date.now();
                updateStatsDisplay();
                updatePlayerPosition(q, r);
            }
        }
        selectedHex = null;
    } else {
        // First click - show terrain info in info panel
        selectedHex = hex;
        hex.setAttribute('stroke', '#000000');
        hex.setAttribute('stroke-width', '3');
        
        document.getElementById('game-message').className = 'terrain-info';
        document.getElementById('game-message').innerHTML = `
            <h3>${terrainInfo.name}</h3>
            <p><em>${terrainInfo.quote}</em></p>
        `;
    }
}

// Create the hex grid
function createHexGrid() {
  const group = document.getElementById('hexGroup');
  const gridSize = 3;
    
  // Position base camp in top row with valid q coordinate
  let baseQ, baseR;
  baseR = -gridSize;  // Force it to be in the top row
    
  // Calculate valid q range for this r value
  const minQ = Math.max(-gridSize, -gridSize - baseR);
  const maxQ = Math.min(gridSize, gridSize - baseR);
  baseQ = minQ + Math.floor(Math.random() * (maxQ - minQ + 1));
    
  baseCamp = { q: baseQ, r: baseR };
    
  // Position player at base camp initially
  playerPosition = { q: baseQ, r: baseR };
    
  // Position south pole in bottom row
  let southQ;
  let southR;
  do {
      southR = gridSize;  // Force it to be in the bottom row
      // Use same q range calculation for bottom row
      const minSouthQ = Math.max(-gridSize, -gridSize - southR);
      const maxSouthQ = Math.min(gridSize, gridSize - southR);
      southQ = minSouthQ + Math.floor(Math.random() * (maxSouthQ - minSouthQ + 1));
  } while (southQ === baseQ && southR === baseR);
  southPole = { q: southQ, r: southR };
  
  // Create terrain hexes
  for (let q = -gridSize; q <= gridSize; q++) {
      for (let r = -gridSize; r <= gridSize; r++) {
          if (Math.abs(q + r) <= gridSize) {
              const x = hexWidth * (q + r/2);
              const y = hexHeight * (r * 3/4);
              
              // Create terrain hex
              const hex = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
              let terrain;
              
              if (q === baseCamp.q && r === baseCamp.r) {
                  terrain = 'BASE_CAMP';
                  hex.setAttribute("fill", SPECIAL_LOCATIONS.BASE_CAMP.color);
              } else if (q === southPole.q && r === southPole.r) {
                  terrain = 'SOUTH_POLE';
                  hex.setAttribute("fill", SPECIAL_LOCATIONS.SOUTH_POLE.color);
              } else {
                  terrain = assignRandomTerrain();
                  hex.setAttribute("fill", TERRAIN_TYPES[terrain].color);
              }
              
              hex.setAttribute("points", createHexPoints(hexSize));
              hex.setAttribute("transform", `translate(${x}, ${y})`);
              hex.setAttribute("stroke", "#ffffff");
              hex.setAttribute("stroke-width", "1");
              hex.setAttribute("data-q", q);
              hex.setAttribute("data-r", r);
              hex.setAttribute("data-terrain", terrain);
              
              hex.addEventListener('pointerdown', handleHexClick);
              group.appendChild(hex);
              
              // Create fog overlay for this hex
              const fog = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
              fog.setAttribute("points", createHexPoints(hexSize));
              fog.setAttribute("transform", `translate(${x}, ${y})`);
              fog.setAttribute("class", "fog");
              fog.setAttribute("data-q", q);
              fog.setAttribute("data-r", r);
              fog.setAttribute("fill-opacity", "1");
              fog.setAttribute("id", `fog-${q},${r}`);
              group.appendChild(fog);
          }
      }
  }

  // Initialize visibility
  visitedHexes.add(`${playerPosition.q},${playerPosition.r}`);
  createPlayerMarker();
  centerViewport();

  updateVisibility();
  updateCurrentLocationInfo();
}

        // Initialize
        createHexGrid();
        // Start the stats update loop
        setInterval(updateStats, 50);
        showInitialMessage();

function restartGame() {
    // Hide restart button
    document.getElementById('restart-button').classList.add('hidden');
    document.getElementById('restart-button').style.display = 'none';

    southPoleSpotted = false;
    
    // Reset all stats
    stats.health = STATS.MAX_VALUE;
    stats.stamina = STATS.MAX_VALUE;
    stats.hunger = STATS.MAX_VALUE;
    southPoleVisited = false;
    
    // Clear visited hexes except base camp
    visitedHexes.clear();
    visitedHexes.add(`${baseCamp.q},${baseCamp.r}`);
    
    // Reset player position and center viewport
    const hexGroup = document.getElementById('hexGroup');
    const gameGrid = document.getElementById('gameGrid');
    const gridRect = gameGrid.getBoundingClientRect();
    const center = getHexCenter(baseCamp.q, baseCamp.r);
    const translateX = (gridRect.width / 2) - center.x;
    const translateY = (gridRect.height / 2) - center.y;
    hexGroup.setAttribute('transform', `translate(${translateX}, ${translateY})`);
    
    updatePlayerPosition(baseCamp.q, baseCamp.r);
    
    // Show starting message
    document.getElementById('game-message').className = 'narrative';
    document.getElementById('game-message').innerHTML = 
        "Before you lies the vast Antarctic expanse, untamed and unforgiving. The freezing wind howls a challenge promising either immortal glory or eternal rest beneath the ice.";
    
    // Reset last update times
    lastStatUpdate = Date.now();
    lastMoveTime = Date.now();
}
    </script>
</body>
</html>