// Ship Life - Cinematic System

let scenesData = null;
let cinematicState = {
    isPlaying: false,
    currentScene: null,
    eventQueue: [],
    elapsedTime: 0,
    elements: {
        background: null,
        caption: null,
        narrator: null,
        portrait_left: null,
        portrait_right: null,
        dialogue: null
    },
    skipRequested: false
};

/**
 * Load scenes data
 */
async function loadScenes() {
    if (!scenesData) {
        const response = await fetch('data/scenes.json');
        scenesData = await response.json();
    }
    return scenesData;
}

/**
 * Play a cinematic scene
 */
async function playCinematic(sceneId) {
    const data = await loadScenes();
    const scene = data.scenes.find(s => s.scene_id === sceneId);
    
    if (!scene) {
        console.error(`Scene not found: ${sceneId}`);
        return;
    }
    
    console.log(`Playing cinematic: ${sceneId}`);
    
    // Lock navigation
    lockNavigation();
    
    // Show cinematic container
    const container = createCinematicContainer();
    
    // Initialize state
    cinematicState.isPlaying = true;
    cinematicState.currentScene = scene;
    cinematicState.skipRequested = false;
    cinematicState.eventQueue = buildEventQueue(scene.events);
    cinematicState.elapsedTime = 0;
    
    // Play the scene
    await playSceneTimeline(scene, container);
    
    // Cleanup
    removeCinematicContainer(container);
    unlockNavigation();
    cinematicState.isPlaying = false;
    
    console.log(`Cinematic complete: ${sceneId}`);
}

/**
 * Build event queue with absolute timestamps
 * Auto-schedules exit events for elements with lifetime
 */
function buildEventQueue(events) {
    const queue = [];
    let absoluteTime = 0;
    
    events.forEach(event => {
        absoluteTime += event.delay;
        const mainEvent = {
            ...event,
            triggerTime: absoluteTime
        };
        queue.push(mainEvent);
        
        // Auto-schedule exit event if lifetime is specified
        if (event.lifetime !== undefined && event.lifetime > 0) {
            const exitEvent = createExitEvent(event, absoluteTime);
            queue.push(exitEvent);
        }
    });
    
    // Sort by trigger time to ensure proper order
    queue.sort((a, b) => a.triggerTime - b.triggerTime);
    
    return queue;
}

/**
 * Create an exit event for an element with lifetime
 */
function createExitEvent(enterEvent, enterTriggerTime) {
    // Determine exit action (smart defaults)
    let exitAction = enterEvent.exit_action;
    if (!exitAction) {
        // Smart defaults: opposite of entry action
        const actionMap = {
            'fade_in': 'fade_out',
            'slide_in': 'slide_out',
            'show': 'hide',
            'cut_in': 'clear'
        };
        exitAction = actionMap[enterEvent.action] || 'fade_out';
    }
    
    // Determine exit duration (smart defaults)
    let exitDuration = enterEvent.exit_duration;
    if (exitDuration === undefined) {
        // Default to entry duration
        exitDuration = enterEvent.duration || 1.0;
    }
    
    return {
        type: enterEvent.type,
        action: exitAction,
        duration: exitDuration,
        triggerTime: enterTriggerTime + enterEvent.lifetime,
        delay: 0, // Not used for auto-generated events
        side: enterEvent.side, // Preserve side for portraits
        _autoGenerated: true // Mark as auto-generated for debugging
    };
}

/**
 * Play scene timeline
 */
async function playSceneTimeline(scene, container) {
    return new Promise((resolve) => {
        const startTime = Date.now();
        let lastEventTime = 0;
        let lastEventDuration = 0;
        
        function tick() {
            if (cinematicState.skipRequested) {
                // Fast-forward: apply all remaining events instantly
                fastForwardScene(container);
                resolve();
                return;
            }
            
            const elapsed = (Date.now() - startTime) / 1000;
            cinematicState.elapsedTime = elapsed;
            
            // Process events that should trigger now
            while (cinematicState.eventQueue.length > 0) {
                const nextEvent = cinematicState.eventQueue[0];
                
                if (nextEvent.triggerTime <= elapsed) {
                    cinematicState.eventQueue.shift();
                    processEvent(nextEvent, container);
                    // Track when this event was triggered and its duration
                    lastEventTime = elapsed;
                    lastEventDuration = nextEvent.duration || 0;
                } else {
                    break;
                }
            }
            
            // Continue if there are more events OR if last event's animation hasn't finished
            const allEventsProcessed = cinematicState.eventQueue.length === 0;
            const lastAnimationComplete = elapsed >= (lastEventTime + lastEventDuration);
            
            if (!allEventsProcessed || !lastAnimationComplete) {
                requestAnimationFrame(tick);
            } else {
                resolve();
            }
        }
        
        tick();
    });
}

/**
 * Process a single event
 */
function processEvent(event, container) {
    console.log(`[Cinematic] Event: ${event.type} - ${event.action}`);
    
    switch (event.type) {
        case 'background':
            processBackgroundEvent(event, container);
            break;
        case 'caption':
            processCaptionEvent(event, container);
            break;
        case 'narrator':
            processNarratorEvent(event, container);
            break;
        case 'portrait':
            processPortraitEvent(event, container);
            break;
        case 'dialogue':
            processDialogueEvent(event, container);
            break;
        case 'all':
            processAllEvent(event, container);
            break;
        default:
            console.warn(`Unknown event type: ${event.type}`);
    }
}

/**
 * Process background event
 */
function processBackgroundEvent(event, container) {
    const layer = container.querySelector('.cinematic-background');
    
    if (event.action === 'fade_in' || event.action === 'cut_in') {
        // Set background
        if (event.asset) {
            layer.style.backgroundImage = `url('assets/scenes/${event.asset}')`;
        } else if (event.color) {
            layer.style.backgroundColor = resolveColor(event.color);
            layer.style.backgroundImage = 'none';
        }
        
        if (event.action === 'fade_in') {
            fadeIn(layer, event.duration);
        } else {
            layer.style.opacity = '1';
        }
    } else if (event.action === 'fade_out') {
        fadeOut(layer, event.duration);
    }
}

/**
 * Process caption event
 */
function processCaptionEvent(event, container) {
    const layer = container.querySelector('.cinematic-caption');
    
    if (event.action === 'fade_in' || event.action === 'show') {
        layer.textContent = event.text;
        layer.className = 'cinematic-caption';
        
        if (event.size) layer.classList.add(`size-${event.size}`);
        if (event.style) layer.classList.add(`style-${event.style}`);
        
        if (event.action === 'fade_in') {
            fadeIn(layer, event.duration);
        } else {
            layer.style.opacity = '1';
        }
    } else if (event.action === 'fade_out') {
        fadeOut(layer, event.duration, () => layer.textContent = '');
    } else if (event.action === 'hide') {
        layer.style.opacity = '0';
        layer.textContent = '';
    }
}

/**
 * Process narrator event
 */
function processNarratorEvent(event, container) {
    const layer = container.querySelector('.cinematic-narrator');
    
    if (event.action === 'fade_in' || event.action === 'show') {
        layer.textContent = event.text;
        layer.className = 'cinematic-narrator';
        
        if (event.align) layer.style.textAlign = event.align;
        if (event.size) layer.classList.add(`size-${event.size}`);
        if (event.style) layer.classList.add(`style-${event.style}`);
        
        if (event.action === 'fade_in') {
            fadeIn(layer, event.duration);
        } else {
            layer.style.opacity = '1';
        }
    } else if (event.action === 'fade_out') {
        fadeOut(layer, event.duration, () => layer.textContent = '');
    } else if (event.action === 'hide') {
        layer.style.opacity = '0';
        layer.textContent = '';
    }
}

/**
 * Process portrait event
 */
function processPortraitEvent(event, container) {
    const layerClass = event.side === 'left' ? '.cinematic-portrait-left' : '.cinematic-portrait-right';
    const layer = container.querySelector(layerClass);
    
    if (event.action === 'slide_in' || event.action === 'fade_in' || event.action === 'cut_in') {
        // Get guardian portrait
        const guardian = getGuardianById(event.character);
        if (guardian && guardian.portrait) {
            renderVisual(guardian.portrait, layer);
        } else {
            layer.textContent = event.character;
        }
        
        if (event.action === 'slide_in') {
            slideIn(layer, event.side, event.duration);
        } else if (event.action === 'fade_in') {
            fadeIn(layer, event.duration);
        } else {
            layer.style.opacity = '1';
            layer.style.transform = 'translateX(0)';
        }
    } else if (event.action === 'slide_out') {
        slideOut(layer, event.side, event.duration, () => layer.innerHTML = '');
    } else if (event.action === 'fade_out') {
        fadeOut(layer, event.duration, () => layer.innerHTML = '');
    }
}

/**
 * Process dialogue event
 */
function processDialogueEvent(event, container) {
    const layer = container.querySelector('.cinematic-dialogue');
    
    if (event.action === 'show') {
        const guardian = getGuardianById(event.character);
        const characterName = guardian ? guardian.name : event.character;
        
        layer.innerHTML = `
            <div class="dialogue-name">${characterName}</div>
            <div class="dialogue-text">${event.text}</div>
        `;
        
        fadeIn(layer, 0.3);
    } else if (event.action === 'hide') {
        fadeOut(layer, 0.3, () => layer.innerHTML = '');
    }
}

/**
 * Process "all" event (clear/fade all elements)
 */
function processAllEvent(event, container) {
    const layers = [
        '.cinematic-background',
        '.cinematic-caption',
        '.cinematic-narrator',
        '.cinematic-portrait-left',
        '.cinematic-portrait-right',
        '.cinematic-dialogue'
    ];
    
    layers.forEach(selector => {
        const layer = container.querySelector(selector);
        if (event.action === 'fade_out') {
            fadeOut(layer, event.duration, () => {
                if (selector !== '.cinematic-background') {
                    layer.innerHTML = '';
                    layer.textContent = '';
                }
            });
        } else if (event.action === 'clear') {
            layer.style.opacity = '0';
            if (selector !== '.cinematic-background') {
                layer.innerHTML = '';
                layer.textContent = '';
            }
        }
    });
}

/**
 * Fast-forward scene (skip functionality)
 */
function fastForwardScene(container) {
    // Apply all remaining events instantly
    cinematicState.eventQueue.forEach(event => {
        // Set duration to 0 for instant application
        event.duration = 0;
        processEvent(event, container);
    });
    
    cinematicState.eventQueue = [];
}

/**
 * Create cinematic container
 */
function createCinematicContainer() {
    const container = document.createElement('div');
    container.id = 'cinematic-container';
    container.className = 'cinematic-container';
    
    container.innerHTML = `
        <div class="cinematic-background"></div>
        <div class="cinematic-caption"></div>
        <div class="cinematic-narrator"></div>
        <div class="cinematic-portrait-left"></div>
        <div class="cinematic-portrait-right"></div>
        <div class="cinematic-dialogue"></div>
        <button class="cinematic-skip">Skip</button>
    `;
    
    // Wire skip button
    const skipBtn = container.querySelector('.cinematic-skip');
    skipBtn.onclick = () => {
        cinematicState.skipRequested = true;
    };
    
    document.body.appendChild(container);
    return container;
}

/**
 * Remove cinematic container
 */
function removeCinematicContainer(container) {
    if (container && container.parentNode) {
        container.parentNode.removeChild(container);
    }
}

/**
 * Check if any animations are still running
 */
function checkActiveAnimations(container) {
    const layers = container.querySelectorAll('[style*="transition"]');
    // Simplified: assume animations complete based on duration
    // Could be enhanced with transitionend listeners
    return false;
}

/**
 * Resolve color shortcuts
 */
function resolveColor(color) {
    const colorMap = {
        'black': '#000000',
        'white': '#FFFFFF',
        'space_blue': '#0a1128',
        'deep_space': '#05080f'
    };
    
    return colorMap[color] || color;
}

/**
 * Animation utilities
 */
function fadeIn(element, duration) {
    element.style.transition = `opacity ${duration}s ease-in-out`;
    element.style.opacity = '0';
    
    requestAnimationFrame(() => {
        element.style.opacity = '1';
    });
}

function fadeOut(element, duration, callback) {
    element.style.transition = `opacity ${duration}s ease-in-out`;
    element.style.opacity = '1';
    
    requestAnimationFrame(() => {
        element.style.opacity = '0';
    });
    
    if (callback) {
        setTimeout(callback, duration * 1000);
    }
}

function slideIn(element, side, duration) {
    const startPos = side === 'left' ? '-100%' : '100%';
    element.style.transition = `transform ${duration}s ease-out, opacity ${duration}s ease-out`;
    element.style.transform = `translateX(${startPos})`;
    element.style.opacity = '0';
    
    requestAnimationFrame(() => {
        element.style.transform = 'translateX(0)';
        element.style.opacity = '1';
    });
}

function slideOut(element, side, duration, callback) {
    const endPos = side === 'left' ? '-100%' : '100%';
    element.style.transition = `transform ${duration}s ease-in, opacity ${duration}s ease-in`;
    element.style.transform = 'translateX(0)';
    element.style.opacity = '1';
    
    requestAnimationFrame(() => {
        element.style.transform = `translateX(${endPos})`;
        element.style.opacity = '0';
    });
    
    if (callback) {
        setTimeout(callback, duration * 1000);
    }
}

console.log('Cinematic system loaded.');
